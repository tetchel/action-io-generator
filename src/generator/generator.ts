
import * as jsYaml from "js-yaml";
import * as fs from "fs";
import * as path from "path";

import { promisify } from 'util';
import * as logger from "../util/logger";
import { ActionYml, InputOutputEntries, InputOrOutput } from './types';

export default async function generator(actionYmlFile: string, outFile: string, watch: boolean): Promise<void> {
    if (![ ".yml", ".yaml" ].includes(path.extname(actionYmlFile))) {
        logger.log(`Warning: ${actionYmlFile} does not appear to be a yaml file.`);
    }

    await generateInner(actionYmlFile, outFile);

    if (!watch) {
        // Done
        return;
    }

    logger.log(`Watching ${actionYmlFile} for further changes (CTRL + C to exit)...`);

    let modifyingProm: Promise<unknown> | undefined;

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fs.watch(actionYmlFile, async (_event: string, _filename: string) => {
        logger.log(`${actionYmlFile} changed`);

        if (modifyingProm) {
            logger.log(`Update already in progress, waiting...`);
            await modifyingProm;
            logger.log(`Done waiting`);
        }

        modifyingProm = generateInner(actionYmlFile, outFile)
        .catch((err) => {
            console.error(err);
        })
        .finally(() => modifyingProm = undefined);
    });
}

async function generateInner(actionYmlFile: string, outFile: string): Promise<void> {
    const actionYml = await loadActionYml(actionYmlFile);

    const inputs = Object.entries(actionYml.inputs || []);
    const outputs = Object.entries(actionYml.outputs || []);

    logger.log(`Found ${inputs.length} input${inputs.length === 1 ? "" : "s"} and ${outputs.length} output${outputs.length === 1 ? "" : "s"}.`);

    await outputEnums(outFile, inputs, outputs);
}

async function loadActionYml(actionYmlFile: string): Promise<ActionYml> {
    const actionYmlContents = (await promisify(fs.readFile)(actionYmlFile)).toString();

    const actionYmlRaw = jsYaml.safeLoad(actionYmlContents, {
        onWarning: (e) => {
            logger.log(`Warning loading ${actionYmlFile}: `, e);
        }
    });

    if (actionYmlRaw == null) {
        throw new Error(`Action yaml load returned ${actionYmlRaw}`);
    }
    else if (typeof actionYmlRaw === "string") {
        throw new Error(`Failed to parse ${actionYmlFile} as yaml`);
    }

    const actionYml = actionYmlRaw as ActionYml;
    return actionYml;
}

async function outputEnums(outFile: string, inputs: InputOutputEntries, outputs: InputOutputEntries): Promise<void> {
    let outputFileContents =
`
///// This file was auto-generated by action-io-generator. Do not edit by hand!

`;
    outputFileContents += enumify("Inputs", inputs);
    outputFileContents += `\n`;
    outputFileContents += enumify("Outputs", outputs);

    await promisify(fs.writeFile)(outFile, outputFileContents);
    logger.log(`Output input and output enums to ${outFile}`);
}

function enumify(enumName: string, inputsOrOutputs: [string, InputOrOutput][]) {
    inputsOrOutputs.sort();

    const OUTPUT_INDENT = " ".repeat(4);

    return inputsOrOutputs.reduce((inputsBuilder: string, [name, props]) => {
        inputsBuilder +=
`${OUTPUT_INDENT}/**
${OUTPUT_INDENT} * ${props.description.trim().replace("\\n", " ")}
${OUTPUT_INDENT} * Required: ${!!props.required}
${OUTPUT_INDENT} * Default: ${props.default !== undefined ? `"${props.default}"` : "None."}
${OUTPUT_INDENT} */
${OUTPUT_INDENT}${name.toUpperCase().replace(/-/g, "_")} = "${name}",
`;
        return inputsBuilder;
    }, `export enum ${enumName} {\n`) + `}\n`;
}
