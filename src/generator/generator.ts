import * as jsYaml from "js-yaml";
import * as fs from "fs";
import * as path from "path";

import { promisify } from "util";
import * as logger from "../util/logger";
import { ActionYml, InputOutputEntries, InputOrOutput } from "./types";

export default async function generator(actionYmlFile: string, outFile: string, watch: boolean): Promise<void> {
    if (![ ".yml", ".yaml" ].includes(path.extname(actionYmlFile))) {
        logger.log(`Warning: ${actionYmlFile} does not appear to be a yaml file.`);
    }

    await generateInner(actionYmlFile, outFile);

    if (!watch) {
        // Done
        return;
    }

    logger.log(`Watching ${actionYmlFile} for further changes (CTRL + C to exit)...`);

    let modifyingProm: Promise<unknown> | undefined;

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fs.watch(actionYmlFile, async (_event: string, _filename: string) => {
        logger.log(`${actionYmlFile} changed`);

        if (modifyingProm) {
            logger.log(`Update already in progress, waiting...`);
            await modifyingProm;
            logger.log(`Done waiting`);
        }

        modifyingProm = generateInner(actionYmlFile, outFile)
            .catch((err) => {
                console.error(err);
            })
            .finally(() => {
                modifyingProm = undefined;
            });
    });
}

async function generateInner(actionYmlFile: string, outFile: string): Promise<void> {
    const actionYml = await loadActionYml(actionYmlFile);

    const inputs = Object.entries(actionYml.inputs || []);
    const outputs = Object.entries(actionYml.outputs || []);

    logger.log(
        `Found ${inputs.length} input${inputs.length === 1 ? "" : "s"} `
        + `and ${outputs.length} output${outputs.length === 1 ? "" : "s"}.`,
    );

    await outputEnums(outFile, inputs, outputs);
}

async function loadActionYml(actionYmlFile: string): Promise<ActionYml> {
    const actionYmlContents = (await promisify(fs.readFile)(actionYmlFile)).toString();

    const actionYmlRaw = jsYaml.safeLoad(actionYmlContents, {
        onWarning: (e) => {
            logger.log(`Warning loading ${actionYmlFile}: `, e);
        },
    });

    if (actionYmlRaw == null) {
        throw new Error(`Action yaml load returned ${actionYmlRaw}`);
    }
    else if (typeof actionYmlRaw === "string") {
        throw new Error(`Failed to parse ${actionYmlFile} as yaml`);
    }

    const actionYml = actionYmlRaw as ActionYml;
    return actionYml;
}

async function outputEnums(outFile: string, inputs: InputOutputEntries, outputs: InputOutputEntries): Promise<void> {
    let outputFileContents = `// This file was auto-generated by action-io-generator. Do not edit by hand!\n`;
    outputFileContents += enumify("Inputs", inputs);
    outputFileContents += `\n`;
    outputFileContents += enumify("Outputs", outputs);

    await promisify(fs.writeFile)(outFile, outputFileContents);
    logger.log(`Output input and output enums to ${outFile}`);
}

function enumify(enumName: string, inputsOrOutputs: [string, InputOrOutput][]): string {
    inputsOrOutputs.sort();

    const OUTPUT_INDENT = " ".repeat(4);
    const LINE_START = `${OUTPUT_INDENT} *`;

    return inputsOrOutputs.reduce((accumulator, [ name, props ]) => {
        const foldedDescription = props.description.trim()
            .replace(/\r\n/g, `\n`)                     // want windows line endings? too bad
            .replace(/[\r\n]/g, `\n${LINE_START} `);

        const enumifiedName = name.toUpperCase().replace(/-/g, "_");

        // eslint-disable-next-line no-param-reassign,operator-linebreak
        accumulator +=
`${OUTPUT_INDENT}/**
${LINE_START} ${foldedDescription}
${LINE_START} Required: ${!!props.required}
${LINE_START} Default: ${props.default !== undefined ? `"${props.default}"` : "None."}
${LINE_START}/
${OUTPUT_INDENT}${enumifiedName} = "${name}",
`;
        return accumulator;
    }, `export enum ${enumName} {\n`) + `}\n`;
}
